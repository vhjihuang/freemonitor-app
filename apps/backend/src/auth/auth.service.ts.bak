import { Injectable, Inject, BadRequestException, UnauthorizedException, ConflictException, InternalServerErrorException } from '@nestjs/common';
import { PrismaService } from "../../prisma/prisma.service";
import { BcryptHashingService } from "../hashing/hashing.service";
import { JwtService } from "@nestjs/jwt";
import { ConfigService } from '@nestjs/config';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';
import { TokenResponse } from '@freemonitor/types';
import { HASHING_SERVICE } from '../hashing/hashing.service.token';
import { JwtConfig } from '../config/jwt.config';
import { MailService } from '../mail/mail.service';
import { User } from '@prisma/client';
import { UserResponseDto } from '@freemonitor/types';
import { Role } from '@freemonitor/types';
import { AppLoggerService } from '../common/services/logger.service';
import { TokenBlacklistService } from './services/token-blacklist.service';

@Injectable()
export class AuthService {
  private logger;
  
  constructor(
    private prisma: PrismaService,
    @Inject(HASHING_SERVICE) private hashingService: BcryptHashingService,
    private jwtService: JwtService,
    private configService: ConfigService,
    private mailService: MailService,
    private tokenBlacklistService: TokenBlacklistService,
    private appLoggerService: AppLoggerService
  ) {
    this.logger = appLoggerService.createLogger(AuthService.name);
    this.logger.debug('AuthService初始化完成');
  }

  /**
   * 验证用户凭据
   * @param email 邮箱
   * @param password 明文密码
   * @returns 用户对象（不含密码）
   */
  async validateUser(email: string, password: string ) : Promise< UserResponseDto | null> {
    const startTime = Date.now();
    
    // 输入验证
    if (!email || !password) {
      this.logger.warn('用户验证失败: 邮箱或密码为空');
      return null;
    }
    
    this.logger.debug(`开始验证用户: ${email}`);
    
    try {
      // 查找活跃用户
      const user = await this.prisma.user.findUnique({
        where: { email, deletedAt: null, isActive: true },
        select: { id: true, email: true, name: true, password: true, role: true }
      });
      
      if (!user?.password) {
        this.logger.warn(`用户验证失败: 用户不存在或已禁用 - ${email}`);
        return null;
      }
      
      // 验证密码
      const isPasswordValid = await this.hashingService.compare(password, user.password);
      
      if (!isPasswordValid) {
        this.logger.warn(`用户验证失败: 密码不匹配 - ${email}`);
        return null;
      }
      
      // 更新最后登录时间
      await this.prisma.user.update({
        where: { id: user.id },
        data: { lastLoginAt: new Date() }
      });
      
      const executionTime = Date.now() - startTime;
      this.logger.info(`用户验证成功: ${email} (ID: ${user.id})`, {
        userId: user.id,
        userRole: user.role,
        executionTime: executionTime
      });
      
      return {
        id: String(user.id),
        email: user.email,
        name: user.name ?? undefined,
        role: user.role as Role
      };
    } catch (error) {
      this.logger.error(`用户验证过程中发生错误: ${error.message}`, error.stack, undefined, {
        email: email,
        errorType: error.constructor.name
      });
      throw error;
    }
  }

  /**
   * 为用户生成并存储刷新令牌
   * @param userId 用户ID
   * @param ipAddress IP地址
   * @param userAgent 用户代理
   * @returns 刷新令牌
   */
  private async generateRefreshToken(userId: string, ipAddress: string, userAgent: string): Promise<string> {
    const jwtConfig = this.configService.get<JwtConfig>('jwt');
    const refreshToken = this.jwtService.sign({ sub: userId }, {
      expiresIn: jwtConfig.refreshIn
    });

    // 计算过期时间
    const expiryDate = new Date();
    const refreshIn = jwtConfig.refreshIn;
    if (refreshIn.endsWith('d')) {
      expiryDate.setDate(expiryDate.getDate() + parseInt(refreshIn));
    } else if (refreshIn.endsWith('h')) {
      expiryDate.setHours(expiryDate.getHours() + parseInt(refreshIn));
    } else if (refreshIn.endsWith('m')) {
      expiryDate.setMinutes(expiryDate.getMinutes() + parseInt(refreshIn));
    }

    // 存储刷新令牌到数据库
    await this.prisma.refreshToken.create({
      data: {
        token: refreshToken,
        userId: userId,
        ipAddress: ipAddress,
        userAgent: userAgent,
        expiresAt: expiryDate
      }
    });

    return refreshToken;
  }

  async login(loginDto: LoginDto, ipAddress: string, userAgent: string): Promise<TokenResponse> {
    const startTime = Date.now();
    
    // 输入验证
    if (!loginDto.email || !loginDto.password) {
      this.logger.warn('登录失败: 邮箱或密码不能为空', { ipAddress, userAgent });
      throw new UnauthorizedException('邮箱和密码不能为空');
    }
    
    this.logger.debug(`用户登录请求: ${loginDto.email}`, { ipAddress, userAgent });
    
    try {
      // 验证用户凭据
      const user = await this.validateUser(loginDto.email, loginDto.password);
      
      if (!user) {
        this.logger.warn(`登录失败: 邮箱或密码错误 - ${loginDto.email}`, { ipAddress, userAgent });
        throw new UnauthorizedException('邮箱或密码错误');
      }
      
      // 生成访问令牌
      const payload = { sub: user.id, email: user.email };
      const jwtConfig = this.configService.get<JwtConfig>('jwt');
      
      const accessToken = this.jwtService.sign(payload, {
        expiresIn: jwtConfig.expiresIn
      });
      
      // 生成并存储刷新令牌
      const refreshToken = await this.generateRefreshToken(user.id, ipAddress, userAgent);

    return {
      accessToken,
      refreshToken,
      expiresIn: this.configService.get<number>('JWT_EXPIRES_IN_SECONDS', 900),
      user: {
        ...user,
        role: user.role as Role
      }
    }
  }

  /**
   * 用户注册
   * @param registerDto 注册信息
   * @returns 访问令牌和用户信息
   */
  async register(registerDto: RegisterDto, ipAddress: string, userAgent: string) {
    // 检查用户是否已存在
    const existingUser = await this.prisma.user.findUnique({
      where: { email: registerDto.email }
    });
  
    if (existingUser) {
      throw new ConflictException('邮箱已被注册');
    }
  
    // 密码加密
    const hashedPassword = await this.hashingService.hash(registerDto.password);
  
    // 创建新用户
    const user = await this.prisma.user.create({
      data: {
        email: registerDto.email,
        password: hashedPassword,
        name: registerDto.name,
        // 默认为普通用户角色，如果需要管理员可以另外设置
        role: 'USER',
        isActive: true,
        lastLoginAt: new Date()
      },
      select: { 
        id: true, 
        email: true, 
        name: true,
        role: true
      }
    });
  
    // 生成JWT令牌
    const payload = { sub: user.id, email: user.email };
    const jwtConfig = this.configService.get<JwtConfig>('jwt');
    const accessToken = this.jwtService.sign(payload, {
      expiresIn: jwtConfig.expiresIn
    });
  
    // 生成并存储刷新令牌
    const refreshToken = await this.generateRefreshToken(user.id, ipAddress, userAgent);
  
    return {
      accessToken,
      refreshToken,
      expiresIn: this.configService.get<number>('JWT_EXPIRES_IN_SECONDS', 900),
      user: {
        ...user,
        role: user.role as Role
      }
    };
  }

  /**
   * 刷新 access token
   */
  async refresh(token: string, ipAddress: string, userAgent: string): Promise<{ accessToken: string; user: UserResponseDto, expiresIn: number }> {
    const startTime = Date.now();
    const requestInfo = { ipAddress, userAgent };
    
    this.logger.debug('开始刷新访问令牌', requestInfo);
    
    try {
      // 检查token是否为空
      if (!token) {
        this.logger.warn('刷新令牌验证失败: 刷新令牌为空', requestInfo);
        throw new UnauthorizedException('刷新令牌不能为空');
      }
      
      this.logger.debug(`获取到刷新令牌: ${token.substring(0, 10)}...`);

      // 1. 从数据库中查找刷新令牌
      const refreshTokenRecord = await this.prisma.refreshToken.findUnique({
        where: { token },
        include: { user: true }
      });
      
      this.logger.debug('刷新令牌数据库查询完成');

      // 2. 验证刷新令牌
      if (!refreshTokenRecord || refreshTokenRecord.revoked) {
        this.logger.warn('刷新令牌验证失败: 无效的刷新令牌或已被撤销', {
          ...requestInfo,
          tokenExists: !!refreshTokenRecord,
          tokenRevoked: refreshTokenRecord?.revoked
        });
        throw new UnauthorizedException('无效的刷新令牌');
      }

      // 3. 检查是否过期
      if (refreshTokenRecord.expiresAt < new Date()) {
        this.logger.warn('刷新令牌验证失败: 刷新令牌已过期', {
          ...requestInfo,
          userId: refreshTokenRecord.userId,
          expiryDate: refreshTokenRecord.expiresAt
        });
        throw new UnauthorizedException('刷新令牌已过期');
      }

      // 4. 验证用户状态
      const user = refreshTokenRecord.user;
      if (!user || user.deletedAt || !user.isActive) {
        this.logger.warn('刷新令牌验证失败: 用户状态异常', {
          ...requestInfo,
          userId: refreshTokenRecord.userId,
          userExists: !!user,
          userActive: user?.isActive,
          userDeleted: !!user?.deletedAt
        });
        throw new UnauthorizedException('用户状态异常');
      }

      // 5. 撤销旧的刷新令牌
      await this.prisma.refreshToken.update({
        where: { id: refreshTokenRecord.id },
        data: { revoked: true }
      });
      
      this.logger.debug('旧的刷新令牌已成功撤销', {
        userId: user.id,
        tokenId: refreshTokenRecord.id
      });

      // 6. 生成新的访问令牌
      const jwtConfig = this.configService.get<JwtConfig>('jwt');
      const accessToken = this.jwtService.sign(
        { sub: user.id, email: user.email },
        { expiresIn: jwtConfig.expiresIn },
      );
      
      // 记录刷新成功信息
      const executionTime = Date.now() - startTime;
      this.logger.info(`访问令牌刷新成功: 用户 ${user.email} (ID: ${user.id})`, {
        ...requestInfo,
        userId: user.id,
        userRole: user.role,
        executionTime: executionTime
      });

      return { 
        accessToken, 
        user: {
          id: String(user.id),
          email: user.email,
          name: user.name ?? undefined,
          role: user.role as Role
        }, 
        expiresIn: this.configService.get<number>('JWT_EXPIRES_IN_SECONDS', 900)
      };
    } catch (error) {
      const executionTime = Date.now() - startTime;
      this.logger.error(
        '刷新令牌验证失败', 
        error.stack,
        undefined,
        {
          ...requestInfo,
          errorType: error.constructor.name,
          errorMessage: error.message,
          executionTime: executionTime
        }
      );
      throw new UnauthorizedException('刷新令牌无效');
    }
  }

  /**
   * 用户登出，撤销刷新令牌
   */
  async logout(refreshToken: string): Promise<void> {
    const startTime = Date.now();
    
    this.logger.debug('开始用户登出流程');
    
    // 检查刷新令牌是否为空
    if (!refreshToken) {
      this.logger.warn('登出失败: 刷新令牌为空');
      throw new BadRequestException('刷新令牌不能为空');
    }
    
    this.logger.debug(`获取到刷新令牌: ${refreshToken.substring(0, 10)}...`);

    try {
      // 查找并撤销刷新令牌
      const tokenRecord = await this.prisma.refreshToken.findUnique({
        where: { token: refreshToken }
      });
      
      this.logger.debug('刷新令牌数据库查询完成');

      if (tokenRecord && !tokenRecord.revoked) {
        // 将刷新令牌添加到黑名单
        await this.tokenBlacklistService.blacklistToken(refreshToken);
        
        // 标记刷新令牌为已撤销
        await this.prisma.refreshToken.update({
          where: { id: tokenRecord.id },
          data: { revoked: true }
        });
        
        const executionTime = Date.now() - startTime;
        this.logger.info(`用户登出成功: 用户ID ${tokenRecord.userId}`, {
          userId: tokenRecord.userId,
          tokenId: tokenRecord.id,
          executionTime: executionTime
        });
      } else {
        this.logger.warn('登出请求处理: 无效的或已撤销的刷新令牌', {
          tokenExists: !!tokenRecord,
          tokenRevoked: tokenRecord?.revoked
        });
      }
    } catch (error) {
      const executionTime = Date.now() - startTime;
      this.logger.error(
        '用户登出过程中发生错误', 
        error.stack,
        undefined,
        {
          errorType: error.constructor.name,
          errorMessage: error.message,
          executionTime: executionTime
        }
      );
      // 不抛出错误，确保即使在异常情况下用户也能登出
    }
  }

  /**
   * 生成密码重置令牌
   * @param email 用户邮箱
   */
  async generatePasswordResetToken(email: string): Promise<void> {
    const startTime = Date.now();
    const requestInfo = { email };
    
    this.logger.debug('开始密码重置令牌生成流程', requestInfo);
    
    // 验证邮箱格式
    if (!email || !email.includes('@')) {
      this.logger.warn('密码重置请求失败: 无效的邮箱格式', requestInfo);
      throw new BadRequestException('请提供有效的邮箱地址');
    }

    try {
      // 查找用户
      const user = await this.prisma.user.findUnique({
        where: { email, isActive: true },
      });

      this.logger.debug('用户查询完成', { ...requestInfo, userFound: !!user });

      if (!user) {
        // 为了安全，即使用户不存在也不透露信息
        this.logger.warn('密码重置请求处理: 未找到活跃用户', requestInfo);
        return;
      }

      // 生成随机令牌
      const token = Math.random().toString(36).substring(2) + Date.now().toString(36);
      
      // 设置令牌过期时间（1小时）
      const expiresAt = new Date(Date.now() + 3600000);

      this.logger.debug('生成密码重置令牌', {
        userId: user.id,
        email: user.email,
        tokenSnippet: token.substring(0, 10) + '...',
        expiresAt: expiresAt
      });

      // 保存令牌和过期时间到数据库
      await this.prisma.user.update({
        where: { id: user.id },
        data: {
          passwordResetToken: token,
          passwordResetExpiresAt: expiresAt,
        },
      });

      this.logger.debug('密码重置令牌已保存到数据库', { userId: user.id });

      // 发送包含重置链接的邮件给用户
      await this.mailService.sendPasswordResetEmail(user.email, token);
      
      const executionTime = Date.now() - startTime;
      this.logger.info('密码重置令牌生成成功并已发送邮件', {
        userId: user.id,
        email: user.email,
        executionTime: executionTime
      });
    } catch (error) {
      const executionTime = Date.now() - startTime;
      this.logger.error(
        '生成密码重置令牌过程中发生错误', 
        error.stack,
        undefined,
        {
          ...requestInfo,
          errorType: error.constructor.name,
          errorMessage: error.message,
          executionTime: executionTime
        }
      );
      throw new InternalServerErrorException('生成密码重置令牌失败，请稍后再试');
    }
  }

  /**
   * 根据邮箱获取重置令牌（仅用于测试）
   * @param email 用户邮箱
   * @returns 重置令牌
   */
  async getResetTokenByEmail(email: string): Promise<string | null> {
    const startTime = Date.now();
    const requestInfo = { email };
    
    this.logger.debug('开始获取重置令牌（测试方法）', requestInfo);
    
    // 验证邮箱格式
    if (!email || !email.includes('@')) {
      this.logger.warn('获取重置令牌失败: 无效的邮箱格式', requestInfo);
      return null;
    }

    try {
      const user = await this.prisma.user.findUnique({
        where: { email }
      });
      
      const executionTime = Date.now() - startTime;
      this.logger.debug('获取重置令牌完成（测试方法）', {
        ...requestInfo,
        userFound: !!user,
        tokenExists: !!user?.passwordResetToken,
        executionTime: executionTime
      });
      
      return user?.passwordResetToken || null;
    } catch (error) {
      const executionTime = Date.now() - startTime;
      this.logger.error(
        '获取重置令牌过程中发生错误（测试方法）', 
        error.stack,
        undefined,
        {
          ...requestInfo,
          errorType: error.constructor.name,
          errorMessage: error.message,
          executionTime: executionTime
        }
      );
      return null;
    }
  }

  /**
   * 使用重置令牌更新密码
   * @param token 重置令牌
   * @param password 新密码
   */
  async updatePasswordWithResetToken(token: string, password: string): Promise<void> {
    const startTime = Date.now();
    const requestInfo = { token: token.substring(0, 10) + '...' };
    
    this.logger.debug('开始使用重置令牌更新密码流程', requestInfo);
    
    // 验证输入
    if (!token || !password) {
      this.logger.warn('密码重置请求失败: 令牌或新密码为空', requestInfo);
      throw new BadRequestException('令牌和新密码不能为空');
    }
    
    // 密码强度验证
    if (password.length < 8) {
      this.logger.warn('密码重置请求失败: 密码长度不足', requestInfo);
      throw new BadRequestException('新密码至少需要8个字符');
    }

    try {
      // 查找令牌有效且未过期的用户
      const user = await this.prisma.user.findFirst({
        where: {
          passwordResetToken: token,
          passwordResetExpiresAt: {
            gte: new Date(),
          },
          isActive: true,
        },
      });

      this.logger.debug('用户查询完成', { ...requestInfo, userFound: !!user });

      if (!user) {
        this.logger.warn('密码重置请求失败: 无效或已过期的重置令牌', requestInfo);
        throw new BadRequestException('无效或已过期的重置令牌');
      }

      // 加密新密码
      const hashedPassword = await this.hashingService.hash(password);
      
      this.logger.debug('密码加密完成', { userId: user.id });

      // 更新用户密码并清除重置令牌
      await this.prisma.user.update({
        where: { id: user.id },
        data: {
          password: hashedPassword,
          passwordResetToken: null,
          passwordResetExpiresAt: null,
        },
      });
      
      const executionTime = Date.now() - startTime;
      this.logger.info('用户密码重置成功', {
        userId: user.id,
        email: user.email,
        executionTime: executionTime
      });
    } catch (error) {
      const executionTime = Date.now() - startTime;
      
      // 如果是我们主动抛出的异常，保留其原始错误类型和消息
      if (error instanceof BadRequestException) {
        this.logger.warn(error.message, {
          ...requestInfo,
          executionTime: executionTime
        });
        throw error;
      }
      
      // 其他错误视为系统错误
      this.logger.error(
        '更新密码过程中发生错误', 
        error.stack,
        undefined,
        {
          ...requestInfo,
          errorType: error.constructor.name,
          errorMessage: error.message,
          executionTime: executionTime
        }
      );
      throw new InternalServerErrorException('更新密码失败，请稍后再试');
    }
  }
}